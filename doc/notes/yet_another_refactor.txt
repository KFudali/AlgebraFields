tools/
    algebra/
        operator/
            operator.py
            callable_operator.py
        system/
            les <-Operator
        expr/
            expression.py
            callable_expression.py
    geometry
    mesh
discr/
    core/
        domain
        bcs
        operators
        discretization.py
    fd/
        domain
        bcs
        operators
        fd_discretization.py
space/
    core/
        abstract_field.py
        spacebound.py
        space.py
    field/
        field_value.py <-Expression
        field_update.py <-Step
        field.py
        dt/
            explicit <- Field
            implicit <- Field
        operators/
            laplace <- ApplyOperatorExpression
            gradient
    system/
        lesnode
    time/
        ts
        tw
algorithm
    Step
    time_integrator <-space


from tools.geometry import grid
import discrete.fd
import space

fd_grid = grid.StructuredGridND(shape=(4, 4), spacing=(0.01, 0.01))
fd_domain = discrete.fd.FDDomain(fd_grid)

top, bot = fd_domain.grid_boundaries(ax = 0)
left, right = fd_domain.grid_boundaries(ax = 1)

fd_disc = discrete.fd.FDDiscretization(fd_domain)
eq_space = space.EquationSpace(fd_disc)

bc_right = eq_space.bcs.dirichlet(right, value = 0)
bc_left = eq_space.bcs.dirichlet(left, value = 10)
bc_top = eq_space.bcs.neumann(top, value = 0)
bc_bot = eq_space.bcs.neumann(bot, value = 0)

F = eq_space.field(components = 1) (Field)

F.apply_bc(bc_left)
F.apply_bc(bc_right)
F.apply_bc(bc_top)
F.apply_bc(bc_bot)

alg/
    system/
    expression/



# ## lambda d^2/dxdx F(t+1) = (F(t+1) - F(t)) / dt
# ## F(t+1) - dt * lambda * d^2/dxdx F(t+1) = F(t)
dFdt = space.field.der.explicit.Euler(field = F, order = 1) (Field)
les = alg.system.LESStep(
    dFdt.value() * lam * F.operator.laplace()
)
apply_bc_expr_list = [les.apply_bc(bc) for bc in F.bcs]
F.update(les.solve())